c
c	MULIST.FOR  (last updated 8/99)
c
c	This contains subroutines for computing pieces of the boundary of the 
c	Schottky space of genus two. Points in this space correspond to 
c	conjugacy classes of free discontinuous kleinian groups generated by 
c	two linear fractional transformations X and Y. This space is 
c	parametrized by tr(X), tr(Y), and tr(XY). 
c
c	This program takes tr(Y) to be fixed and then solves the equation 
c	tr(W_p/q) =2 for the at most one value of tr(X) that lies on the 
c	boundary of the deformation space. The definition of the words W_p/q
c	may be found in the manuscript on Maskit's embedding. The value of 
c	tr(X) for p/q=0/1 is always taken to be 2. The value of tr(X) in 
c	general is found by a relaxed discrete Newton's iteration (regula 
c	falsi) starting with the value for the previous fraction.
c
c	The output value is mu=i*tr(X).
c
c	INPUT: DENOMINATOR (POSITIVE INTEGER)   (Must be >= QSTART and QEND)
c	       STARTING FRACTION PSTART/QSTART     
C	       ENDING FRACTION PEND/QEND       
C	       TRACE Y 
c	       MOLLIFIER (POSITIVE REAL NUMBER AT MOST 1 IN DOUBLE PRECISION)
c
c	Translations are obtained as follows. If tr(X) belongs to the 
c	slice of the boundary being considered than so do both solutions t
c	to the equation 
c	      t^2-tr(X)tr(Y)t +tr(X)^2 + tr(Y)^2=tr(XYX^-1Y^-1)+2
c	This equation comes from the relation tr(XYX^-1Y^-1)=-2.
c	The solutions are t= tr(XY) and tr(XY^-1). We fix one as tr(XY).
c	Then other translations may be computed from the relation
c	     tr(XY^{n+1})=tr(Y)*tr(XY^n) -tr(XY^{n-1})
c	
	subroutine bndy(pstart,qstart,pend,qend,denom,eta0)
	integer denom,pstart,qstart,pend,qend,
	1    d0,p0,q0,p1,q1,n0,n1
	complex*16 eta,eta0
	d0=denom
	p0=pstart
	q0=qstart
	p1=pend
	q1=qend
	eta=eta0
	n0 = p0/q0
	if(p0.lt.n0*q0) n0=n0-1
	n1 = p1/q1
	if(p1.lt.n1*q1) n1=n1-1
c	CASES
	if( dble(p1)/q1 -dble(p0)/q0 .ge. 1-1.0/d0 ) then
	   call bndstr(0,1,d0-1,d0,d0,eta)
	   call bndout(p0,q0,p1,q1)
	else if(n1 .eq. n0) then
	   call bndstr(p0,q0,p1,q1,d0,eta)
	   call bndout(p0,q0,p1,q1)
	else 
	   call bndstr(p0-n0*q0,q0,d0-1,d0,d0,eta)
	   call bndout(p0,q0,(n0+1)*d0-1,d0)
	   call bndstr(0,1,p1-n1*q1,q1,d0,eta)
	   call bndout(n1,1,p1,q1)
	end if
	call btrail
	end
c
c	STORE MU(P/Q) IN MULIST
c	STORE MU(P/Q - 1) IN MU0LST
c	ASSUMES p0/q0 AND p1/q1 ARE CORRECTLY ADJUSTED
c       ZLIST IS THE LIST OF MU'S FOR ONE P/Q IN A SCATTER PLOT
	subroutine bndstr(pstart,qstart,pend,qend,denom,eta0)
	integer pstart,qstart,pend,qend,denom,p,q,d0,error,errstop
	complex*16 trx,try,trxy,mu,const,eta0,eta,trw,trw0
	logical grpon,epson,outon,raston,curvon,colron
	complex*16 mulist(MAXBNDY),mu0lst(MAXBNDY),zlist(MAXCUSP)
	integer plist(MAXBNDY),qlist(MAXBNDY),icount,trsty,numz,i
	real*8 x0,y0,x1,y1
	character reply
	common /flags/ grpon,epson,outon,raston,curvon
	common /bndlst/ mulist,mu0lst,plist,qlist,icount
	common /bdflag/ errstop,colron
	common /trfmt/ trsty
c	SET INITIAL FRACTION
	eta=eta0
	d0=denom
	p=pstart
	q=qstart
	icount=0
 2	if(q .gt. d0) then
	   call nextpq(p,q,d0,1)
	   go to 2
	end if
c       IF CURVON IS TRUE, IT'S A CURVE
	if(curvon) then
c	DETERMINE TRACE FORMAT
	   trw0=2.0d0
	   if(trsty.gt.3) then
	      trw0=-trw0
	      call traces(trx,try,trxy)
	      const=(0.0d0,1.0d0)*try*trxy
	   end if
	   call zcosh(q*eta,trw)
	   trw=trw0*trw
	   call inimu(p,q,mu,trw,error)
	   if(errstop.gt.0) then
 5	      write(*,*) 'Initial mu = ',mu
	      write(*,*) 'Is this right? (y or n)'
	      read(*,'(A)') reply
	      if(reply .eq. 'n') then
		 write(*,*) 'Enter first guess of mu'
		 read(*,*) mu
		 call solmu(p,q,mu,trw,error)
		 go to 5
	      end if
	   end if
 20	   icount=icount+1
	   plist(icount)=p
	   qlist(icount)=q
	   mulist(icount)=mu
	   if(trsty.le.3) then
	      call traces(mu*(0.0d0,-1.0d0),try,trxy)
	      mu0lst(icount)=mu*try - (0.0d0,1.0d0)*trxy
	   else
	      mu0lst(icount)=const-mu
	   end if
	   call nextpq(p,q,d0,1)
	   if((dble(p)/q) .gt. (dble(pend)/qend)) return
	   error =0
	   call zcosh(q*eta,trw)
	   trw=trw0*trw
	   if(trsty.le.3) then
	      call solmu(p,q,mu,trw,error)
	   else
	      call inimu(p,q,mu,trw,error)
	   end if
	   if(error .ne. 0) then
	      write(*,*) 'Error at ',p,'/',q
	      if(errstop.gt.1) return
	   end if
	   go to 20
c       IF CURVON IS FALSE, IT'S A SCATTERPLOT
	else
	   if(trsty.gt.3) then
	      call traces(trx,try,trxy)
	      const=(0.0d0,1.0d0)*try*trxy
	   end if
	   write(*,*) 'Enter search frame x0,y0,x1,y1: '
	   read(*,*) x0,y0,x1,y1
 30	   call musrch(zlist,eta,x0,y0,x1,y1,p,q,numz)
	   do 35 i=1,numz
	      icount=icount+1
	      plist(icount)=p
	      qlist(icount)=q
	      mulist(icount)=zlist(i)
	      if(trsty.le.3) then
		 call traces(zlist(i)*(0.0d0,-1.0d0),try,trxy)
		 mu0lst(icount)=zlist(i)*try - (0.0d0,1.0d0)*trxy
	      else
		 mu0lst(icount)=const-zlist(i)
	      end if
 35	   continue
	   call nextpq(p,q,d0,1)
	   if((dble(p)/q) .gt. (dble(pend)/qend)) return
	   go to 30
	end if
	end
c       
c	OUTPUTS PIECE OF BOUNDARY PREVIOUSLY STORED BY BNDSTR
	subroutine bndout(pstart,qstart,pend,qend)
	external matmul
	integer pstart,qstart,pend,qend,p,q,i,j,n0,n1,n,
	1    nomove,numpts,maxlev
	complex*16 mulist(MAXBNDY),mu0lst(MAXBNDY),mu,try,trxy
	complex*16 a(4),b(4),c(4),wcen
	real*8 xmin,ymin,xmax,ymax,x0,y0,x1,y1,bound,eps,resol,winrad
	integer plist(MAXBNDY),qlist(MAXBNDY),icount,trsty
	common /gfinfo/ xmin,ymin,xmax,ymax,numpts,maxlev
	common /bnds/ bound,eps,resol,wcen,winrad
	common /trfmt/ trsty
	common /picwin/ x0,y0,x1,y1
	common /bndlst/ mulist,mu0lst,plist,qlist,icount
	common /motion/ nomove
c       SET UP CENTER OF FRAME
	wcen = (dcmplx(x0,y0)+dcmplx(x1,y1))*0.5d0
	winrad = cdabs( wcen - dcmplx(x1,y1) )
	resol=0.0005d0*winrad
	if(nomove.eq.0) numpts=0
c	SEPARATE ACCORDING TO TRACE STYLE
	if(trsty .eq.3 .or. trsty.eq.6) then
c	NO SHIFTS
	   do 10 i=1,icount
	      p=plist(i)
	      q=qlist(i)
 	      call boutpt(dreal(mulist(i)),dimag(mulist(i)),p,q)
 10	   continue
	else if(trsty.eq.4 .or. trsty.eq.5) then
c	RILEY STYLE
	   if((dble(pend)/qend-dble(pstart)/qstart).ge.1.0d0) then
c	IF THE DIFFERENCE EXCEEDS 1 DO THE WHOLE THING
	      do 12 i=1,icount
		 p=plist(i)
		 q=qlist(i)
 		 call boutpt(dreal(mulist(i)),dimag(mulist(i)),p,q)
 12	      continue
	      do 20 i=1,icount
		 p=plist(i)+qlist(i)
		 q=qlist(i)
 		 call boutpt(dreal(mu0lst(i)),dimag(mu0lst(i)),p,q)
 20	      continue
	      call boutpt(dreal(mulist(1)),dimag(mulist(1)),2,1)
	   else
c	IF LESS THAN 1, ASSUME IT FITS IN 1 PERIOD
	      n0=pstart/qstart
	      if(pstart.lt.n0*qstart) n0=n0-1
	      j=abs(mod(n0,2))
	      do 30 i=1,icount
		 p=plist(i)+n0*qlist(i)
		 q=qlist(i)
		 mu=(1-j)*mulist(i)+j*mu0lst(i)
 		 call boutpt(dreal(mu),dimag(mu),p,q)
 30	      continue
	   end if
	else
c	MASKIT STYLE
c	FIND PERIODS DESIRED
	   n0=pstart/qstart
	   if(pstart.lt.n0*qstart) n0=n0-1
	   n1=pend/qend
	   if(pend.lt.n1*qend) n1=n1-1
	   mu =mulist(1)
	   call traces((0.0d0,-1.0d0)*mu,try,trxy)
c	SHIFT MATRIX
	   b(1)=try
	   b(2)=-1.0d0
	   b(3)=1.0d0
	   b(4)=0.0d0
c	PLOT BOUNDARY
	   do 40 n=n0,n1
c	SET UP SHIFT MATRIX
	      a(1)=1.0d0
	      a(2)=0.0d0
	      a(3)=0.0d0
	      a(4)=1.0d0
	      do 42 j=1,abs(n)
		 call matcpy(a,c)
 		 call matmul(c,b,a)
 42	      continue
	      if(n.lt.0) then
		 a(1)=a(4)
		 a(2)=a(3)
	      end if
c	PLOT THIS PERIOD'S POINTS
	      do 55 i=1,icount
		 if((dble(plist(i))/qlist(i))+n
	1	      .lt.(dble(pstart)/qstart)) go to 55
		 if((dble(plist(i))/qlist(i))+n
	1	      .gt.(dble(pend)/qend)) return
		 p=plist(i)+n*qlist(i)
		 q=qlist(i)
		 mu=a(1)*mulist(i)+a(2)*mu0lst(i)
		 call boutpt(dreal(mu),dimag(mu),p,q)
 55	      continue
 40	   continue
	end if
	end
c
c       OLD SCATTERING OF PARABOLICS ROUTINE
	subroutine scatt(p0,q0,p1,q1,denom,eta0)
	integer p,q,p0,q0,p1,q1,d0,denom,nummu,i
	real*8 x0,y0,x1,y1
	complex*16 mulist(1000),eta0,eta
	write(*,*) 'Enter search frame x0,y0,x1,y1: '
	read(*,*) x0,y0,x1,y1
	p=p0
	q=q0
	d0=denom
	eta=eta0
2	if(q .gt. d0) then
	  call nextpq(p,q,d0,1)
	  go to 2
	end if
20	call musrch(mulist,eta,x0,y0,x1,y1,p,q,nummu)
	do 30 i=1,nummu
	  call boutpt(dreal(mulist(i)),dimag(mulist(i)),p,q)
30	continue
	call nextpq(p,q,d0,1)
	if((dble(p)/q) .gt. (dble(p1)/q1)) go to 900
	go to 20
900	call btrail
	end
C	
c	COMPUTE A REAL TRACE RAY
	subroutine ray0(mu0,p0,q0)
	integer p0,q0,p,q,error,i,trsty,numpts,maxlev,errstop
	complex*16 trw,dtrw,mu,mu0,mu1,mudir,wcen
	real*8 step,sigma,tau,xmin,ymin,xmax,ymax,
	1    x0,y0,x1,y1,bound,eps,resol,winrad
	logical grpon,epson,outon,raston,curvon,colron
	common /flags/ grpon,epson,outon,raston,curvon
	common /gfinfo/ xmin,ymin,xmax,ymax,numpts,maxlev
	common /bnds/ bound,eps,resol,wcen,winrad
	common /trfmt/ trsty
	common /picwin/ x0,y0,x1,y1
	common /bdflag/ errstop,colron
	mu=mu0
	p=p0
	q=q0
c       COLOR CYCLING
	if(colron) then
c$$$	      call nxtcol(q)
c$$$	      call nxtcol(p)
	   call nxtcol2(p,q)
	end if
c	INITIAL POINT
	numpts=0
	call plotpt(dreal(mu),dimag(mu))
c	COMPUTE PRECISION STEP
	wcen = (dcmplx(x0,y0)+dcmplx(x1,y1))*0.5d0
	winrad = cdabs( wcen - dcmplx(x1,y1) )
	step=0.002d0*winrad
	resol=0.0005d0*winrad
	do 10 i=1,10000
c	CALCULATE DIRECTION AT MU
	   call diftrw(p,q,(0.0d0,-1.0d0)*mu,dtrw)
	   dtrw=(0.0d0,-1.0d0)*dtrw
	   mudir=dconjg(dtrw)/cdabs(dtrw)
	   if(trsty.gt.3) mudir=-mudir
c	ESTIMATE NEXT MU
	   mu1=mu + step*mudir
c	CALCULATE TRACE AT MU1
	   call gettrw(p,q,(0.0d0,-1.0d0)*mu1,trw)
	   trw=dreal(trw)
	   call solmu(p,q,mu1,trw,error)
	   if(cdabs(mu1-mu).lt.0.5*step) then
	      mu=mu1
	      go to 10
	   end if
c       RETURN IF HEADING OUT OF FRAME
	   if( cdabs(mu1-wcen) .gt. cdabs(mu-wcen) .and.
	1	cdabs(mu1-wcen) .gt. winrad ) return
	   mu=mu1
	   call plotpt(dreal(mu),dimag(mu))
 10	continue
	end
c       
c	OUTPUT A BOUNDARY POINT
c       PTLIN=1    => DRAW AS ISOLATED POINTS
c       OTHERWISE DRAW AS CURVE
	subroutine boutpt(sigma0,tau0,p0,q0)
	integer p0,q0,p,q,errstop,pold,qold,outsty
	real*8 sigma0,tau0,sigma,tau,sigmin,sigmax,taumin,taumax
	logical grpon,epson,outon,raston,curvon,colron
	common /flags/ grpon,epson,outon,raston,curvon
	common /bdflag/ errstop,colron
	common /bndmax/ sigmin,sigmax,taumin,taumax
	common /outfmt/ outsty
	save pold,qold
	p=p0
	q=q0
	sigma=sigma0
	tau=tau0
c       KEEP TRACK OF FRAME
	sigmax =dmax1(sigmax,sigma)
	sigmin =dmin1(sigmin,sigma)
	taumax =dmax1(taumax,tau)
	taumin =dmin1(taumin,tau)
	if(outsty.eq.0) then
	   write(3,'(F19.15,1X,F19.15)') sigma,tau
	else
C       STORE THE LABEL IF REQUESTED
	   call putlab(sigma,tau,p,q)
C       COLOR CYCLING
	   if(colron.and.(p.ne.pold.or.q.ne.qold)) then
c$$$	      call nxtcol(q)
c$$$	      call nxtcol(p)
	      call nxtcol2(p,q)
	      pold=p
	      qold=q
	   end if
	   call plotpt(sigma,tau)
	end if
	end




